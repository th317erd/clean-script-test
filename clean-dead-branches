#!/bin/bash

ORIGIN="origin"
TARGET_BRANCH="production"
OLDER_THAN_DAYS="0"
IGNORE_BRANCHES=("$ORIGIN/dev" "$ORIGIN/development" "$ORIGIN/staging" "$ORIGIN/$TARGET_BRANCH" "$ORIGIN/HEAD" "$ORIGIN/master")

TS=$(date "+%s")
BRANCHES=()
OLDER_THAN_SECONDS=$((OLDER_THAN_DAYS * 86400))
NOT_MERGED=()

IFS='|'; IGNORE_PATTERN=${IGNORE_BRANCHES[*]} ; unset IFS
REMOTE_BRANCHES=$(git branch -r | grep "$ORIGIN/" | grep -vE "$IGNORE_PATTERN")

AGREEMENT=''
read -p "AGREEMENT: THIS SCRIPT IS DESTRUCTIVE BY NATURE. BY USING THIS SCRIPT YOU AGREE TO HOLD THE DEVELOPERS, CONTRIBUTORS, AND ALL INVOLVED PARTIES, FREE FROM ALL LIABILITY. YOU AGREE THAT YOU ARE USING THIS SCRIPT AT YOUR OWN RISK, AND THAT YOU ARE TAKING FULL RESPONSIBILITY FOR ANY DAMAGED CAUSED. TYPE 'agree' TO AGREE TO THESE TERMS: " AGREEMENT

if [[ "$AGREEMENT" != 'agree' ]]; then
  echo "Agreement was not agreed to. Aborting."
  exit 1
fi

echo -e "\e[93mCalculating for $TARGET_BRANCH...\e[0m"

# Get all branch names
for BRANCH in ${REMOTE_BRANCHES[@]}; do
  # Check if branch has been merged with production (exit code other than 0)
  git merge-base --is-ancestor "$BRANCH" "$ORIGIN/$TARGET_BRANCH" >> /dev/null
  IS_MERGED=$?

  if ((IS_MERGED > 0)); then
    NOT_MERGED+=("$BRANCH")
    # echo "Ignoring ${BRANCH} because it isn't yet merged...";
    continue;
  fi

  # Get branch HEAD commit hash
  HASH=$(git rev-parse "$BRANCH")

  # Get timestamp of HASH
  TIME=$(git log -1 --pretty=tformat:%at "$HASH")

  # Get timestamp diff between TIME (HASH) and TS (now)
  DIFF=$((TS - TIME))

  # If diff is larger than our threashold then add it to the BRANCHES array
  if ((DIFF > OLDER_THAN_SECONDS)); then
    # echo "Remote branch: $BRANCH is old $(date -d "@$TIME")"
    BRANCHES+=("$TIME:$BRANCH")
  else
    # echo "Ignoring ${BRANCH} because it isn't old enough...";
    continue
  fi
done

LEN=${#BRANCHES[@]}
if ((LEN == 0)); then
  echo "Nothing to do. Repository is clean"
  exit 0
fi

# Sort our BRANCHES array by TIME
IFS=$'\n'; BRANCHES=($(echo "${BRANCHES[*]}" | sort)); unset IFS

DELETE_BRANCHES=()

IFS=':';
# Iterate BRANCHES array
for BRANCH in "${BRANCHES[@]}"; do
  # Split item apart and place into PARTS array
  read -ra PARTS <<< "$BRANCH"

  # Re-assign parts to specific variables
  BRANCH=${PARTS[1]}
  DELETE_BRANCHES+=("$BRANCH")
done
unset IFS

for BRANCH in "${NOT_MERGED[@]}"; do
  echo -e "\e[32mNot merged (ignoring): $BRANCH\e[0m"
done

for BRANCH in "${DELETE_BRANCHES[@]}"; do
  echo -e "\e[31mWill delete branch: $BRANCH\e[0m"
done

PROMPT=''
read -p "!!!WARNING!!! The listed branches will be deleted locally and from the remote ($ORIGIN)."$'\n'"To continue with this descructive operation, please type (exactly) 'please proceed' and press enter: " PROMPT

if [[ "$PROMPT" == "please proceed" ]]; then
  echo "Proceeding!"
else
  echo "Aborting!"
fi
